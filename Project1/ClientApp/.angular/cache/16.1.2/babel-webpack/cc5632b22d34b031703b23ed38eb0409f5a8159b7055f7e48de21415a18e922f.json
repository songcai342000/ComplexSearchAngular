{"ast":null,"code":"import _asyncToGenerator from \"f:/repos/ComplexSearchAngular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ɵSERVER_CONTEXT, INITIAL_CONFIG, renderApplication, renderModule } from '@angular/platform-server';\nimport { ɵInlineCriticalCssProcessor } from '@nguniversal/common/tools';\nimport * as fs from 'fs';\nimport { resolve, dirname } from 'path';\nimport { URL } from 'url';\n\n/**\n * A common rendering engine utility. This abstracts the logic\n * for handling the platformServer compiler, the module cache, and\n * the document loader\n */\nclass CommonEngine {\n  constructor(bootstrap, providers = []) {\n    this.bootstrap = bootstrap;\n    this.providers = providers;\n    this.templateCache = new Map();\n    this.pageExists = new Map();\n    this.inlineCriticalCssProcessor = new ɵInlineCriticalCssProcessor({\n      minify: true\n    });\n  }\n  /**\n   * Render an HTML document for a specific URL with specified\n   * render options\n   */\n  render(opts) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const {\n        inlineCriticalCss = true\n      } = opts;\n      if (opts.publicPath && opts.documentFilePath && opts.url !== undefined) {\n        const url = new URL(opts.url);\n        // Remove leading forward slash.\n        const pathname = url.pathname.substring(1);\n        const pagePath = resolve(opts.publicPath, pathname, 'index.html');\n        if (pagePath !== resolve(opts.documentFilePath)) {\n          // View path doesn't match with prerender path.\n          let pageExists = _this.pageExists.get(pagePath);\n          if (pageExists === undefined) {\n            pageExists = yield exists(pagePath);\n            _this.pageExists.set(pagePath, pageExists);\n          }\n          if (pageExists) {\n            // Serve pre-rendered page.\n            return fs.promises.readFile(pagePath, 'utf-8');\n          }\n        }\n      }\n      // if opts.document dosen't exist then opts.documentFilePath must\n      const extraProviders = [{\n        provide: ɵSERVER_CONTEXT,\n        useValue: 'ssr'\n      }, ...(opts.providers ?? []), ..._this.providers];\n      let doc = opts.document;\n      if (!doc && opts.documentFilePath) {\n        doc = yield _this.getDocument(opts.documentFilePath);\n      }\n      if (doc) {\n        extraProviders.push({\n          provide: INITIAL_CONFIG,\n          useValue: {\n            document: inlineCriticalCss ?\n            // Workaround for https://github.com/GoogleChromeLabs/critters/issues/64\n            doc.replace(/ media=\"print\" onload=\"this\\.media=['&apos;].+?['&apos;]\"(?: ngCspMedia=\".+\")?><noscript><link .+?><\\/noscript>/g, '>') : doc,\n            url: opts.url\n          }\n        });\n      }\n      const moduleOrFactory = _this.bootstrap || opts.bootstrap;\n      if (!moduleOrFactory) {\n        throw new Error('A module or bootstrap option must be provided.');\n      }\n      const html = yield isBootstrapFn(moduleOrFactory) ? renderApplication(moduleOrFactory, {\n        platformProviders: extraProviders\n      }) : renderModule(moduleOrFactory, {\n        extraProviders\n      });\n      if (!inlineCriticalCss) {\n        return html;\n      }\n      const {\n        content,\n        errors,\n        warnings\n      } = yield _this.inlineCriticalCssProcessor.process(html, {\n        outputPath: opts.publicPath ?? (opts.documentFilePath ? dirname(opts.documentFilePath) : '')\n      });\n      // eslint-disable-next-line no-console\n      warnings?.forEach(m => console.warn(m));\n      // eslint-disable-next-line no-console\n      errors?.forEach(m => console.error(m));\n      return content;\n    })();\n  }\n  /** Retrieve the document from the cache or the filesystem */\n  getDocument(filePath) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let doc = _this2.templateCache.get(filePath);\n      if (!doc) {\n        doc = yield fs.promises.readFile(filePath, 'utf-8');\n        _this2.templateCache.set(filePath, doc);\n      }\n      return doc;\n    })();\n  }\n}\nfunction exists(_x) {\n  return _exists.apply(this, arguments);\n}\nfunction _exists() {\n  _exists = _asyncToGenerator(function* (path) {\n    try {\n      yield fs.promises.access(path, fs.constants.F_OK);\n      return true;\n    } catch {\n      return false;\n    }\n  });\n  return _exists.apply(this, arguments);\n}\nfunction isBootstrapFn(value) {\n  // We can differentiate between a module and a bootstrap function by reading `cmp`:\n  return typeof value === 'function' && !('ɵmod' in value);\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CommonEngine };\n//# sourceMappingURL=engine.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}