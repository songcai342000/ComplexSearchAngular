{"ast":null,"code":"import _asyncToGenerator from \"f:/repos/ComplexSearchAngular/Project1/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport Critters from 'critters';\nimport * as fs from 'fs';\n\n/**\n * Pattern used to extract the media query set by Critters in an `onload` handler.\n */\nconst MEDIA_SET_HANDLER_PATTERN = /^this\\.media=[&apos;\"'](.*)[&apos;\"'];?$/;\n/**\n * Name of the attribute used to save the Critters media query so it can be re-assigned on load.\n */\nconst CSP_MEDIA_ATTR = 'ngCspMedia';\n/**\n * Script text used to change the media value of the link tags.\n */\nconst LINK_LOAD_SCRIPT_CONTENT = [`(() => {`,\n// Save the `children` in a variable since they're a live DOM node collection.\n// We iterate over the direct descendants, instead of going through a `querySelectorAll`,\n// because we know that the tags will be directly inside the `head`.\n`  const children = document.head.children;`,\n// Declare `onLoad` outside the loop to avoid leaking memory.\n// Can't be an arrow function, because we need `this` to refer to the DOM node.\n`  function onLoad() {this.media = this.getAttribute('${CSP_MEDIA_ATTR}');}`,\n// Has to use a plain for loop, because some browsers don't support\n// `forEach` on `children` which is a `HTMLCollection`.\n`  for (let i = 0; i < children.length; i++) {`, `    const child = children[i];`, `    child.hasAttribute('${CSP_MEDIA_ATTR}') && child.addEventListener('load', onLoad);`, `  }`, `})();`].join('\\n');\nclass CrittersExtended extends Critters {\n  constructor(optionsExtended, resourceCache) {\n    var _this;\n    super({\n      logger: {\n        warn: s => this.warnings.push(s),\n        error: s => this.errors.push(s),\n        info: () => {}\n      },\n      logLevel: 'warn',\n      path: optionsExtended.outputPath,\n      publicPath: optionsExtended.deployUrl,\n      compress: !!optionsExtended.minify,\n      pruneSource: false,\n      reduceInlineStyles: false,\n      mergeStylesheets: false,\n      // Note: if `preload` changes to anything other than `media`, the logic in\n      // `embedLinkedStylesheetOverride` will have to be updated.\n      preload: 'media',\n      noscriptFallback: true,\n      inlineFonts: true\n    });\n    _this = this;\n    this.optionsExtended = optionsExtended;\n    this.resourceCache = resourceCache;\n    this.warnings = [];\n    this.errors = [];\n    this.addedCspScriptsDocuments = new WeakSet();\n    this.documentNonces = new WeakMap();\n    /**\n     * Override of the Critters `embedLinkedStylesheet` method\n     * that makes it work with Angular's CSP APIs.\n     */\n    this.embedLinkedStylesheetOverride = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (link, document) {\n        const returnValue = yield _this.initialEmbedLinkedStylesheet(link, document);\n        const cspNonce = _this.findCspNonce(document);\n        if (cspNonce) {\n          const crittersMedia = link.getAttribute('onload')?.match(MEDIA_SET_HANDLER_PATTERN);\n          if (crittersMedia) {\n            // If there's a Critters-generated `onload` handler and the file has an Angular CSP nonce,\n            // we have to remove the handler, because it's incompatible with CSP. We save the value\n            // in a different attribute and we generate a script tag with the nonce that uses\n            // `addEventListener` to apply the media query instead.\n            link.removeAttribute('onload');\n            link.setAttribute(CSP_MEDIA_ATTR, crittersMedia[1]);\n            _this.conditionallyInsertCspLoadingScript(document, cspNonce);\n          }\n          link.prev?.setAttribute('nonce', cspNonce);\n        }\n        return returnValue;\n      });\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    // We can't use inheritance to override `embedLinkedStylesheet`, because it's not declared in\n    // the `Critters` .d.ts which means that we can't call the `super` implementation. TS doesn't\n    // allow for `super` to be cast to a different type.\n    this.initialEmbedLinkedStylesheet = this.embedLinkedStylesheet;\n    this.embedLinkedStylesheet = this.embedLinkedStylesheetOverride;\n  }\n  readFile(path) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let resourceContent = _this2.resourceCache.get(path);\n      if (resourceContent === undefined) {\n        resourceContent = yield fs.promises.readFile(path, 'utf-8');\n        _this2.resourceCache.set(path, resourceContent);\n      }\n      return resourceContent;\n    })();\n  }\n  /**\n   * Finds the CSP nonce for a specific document.\n   */\n  findCspNonce(document) {\n    if (this.documentNonces.has(document)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.documentNonces.get(document);\n    }\n    // HTML attribute are case-insensitive, but the parser used by Critters is case-sensitive.\n    const nonceElement = document.querySelector('[ngCspNonce], [ngcspnonce]');\n    const cspNonce = nonceElement?.getAttribute('ngCspNonce') || nonceElement?.getAttribute('ngcspnonce') || null;\n    this.documentNonces.set(document, cspNonce);\n    return cspNonce;\n  }\n  /**\n   * Inserts the `script` tag that swaps the critical CSS at runtime,\n   * if one hasn't been inserted into the document already.\n   */\n  conditionallyInsertCspLoadingScript(document, nonce) {\n    if (this.addedCspScriptsDocuments.has(document)) {\n      return;\n    }\n    if (document.head.textContent.includes(LINK_LOAD_SCRIPT_CONTENT)) {\n      // Script was already added during the build.\n      this.addedCspScriptsDocuments.add(document);\n      return;\n    }\n    const script = document.createElement('script');\n    script.setAttribute('nonce', nonce);\n    script.textContent = LINK_LOAD_SCRIPT_CONTENT;\n    // Append the script to the head since it needs to\n    // run as early as possible, after the `link` tags.\n    document.head.appendChild(script);\n    this.addedCspScriptsDocuments.add(document);\n  }\n}\nclass InlineCriticalCssProcessor {\n  constructor(options) {\n    this.options = options;\n    this.resourceCache = new Map();\n  }\n  process(html, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const critters = new CrittersExtended({\n        ..._this3.options,\n        ...options\n      }, _this3.resourceCache);\n      const content = yield critters.process(html);\n      return {\n        content,\n        errors: critters.errors.length ? critters.errors : undefined,\n        warnings: critters.warnings.length ? critters.warnings : undefined\n      };\n    })();\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { InlineCriticalCssProcessor as ÉµInlineCriticalCssProcessor };\n//# sourceMappingURL=tools.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}